;; based on an email sent on 2010-04-12 by yh
;; Message-ID: <87fx30kgqa.wl%yh@is.s.u-tokyo.ac.jp>

;; 山本さん
;; (cc: 星野さん)

;; 例題のinput(lisp) と output(SQL)を書いてみました．
;; 書いてみただけで，動作を確かめていません．それは土日にやります．

;; たしか仕様通りのSQLはチューリング完全ではないので，
;; Lispの任意のプログラムを受け取って
;; ・等価なSQLがあれば等価なSQLを返す
;; ・等価な無ければもとのプログラムをそのまま返す
;; という動作をするプログラムは存在しないです(Riceの定理)．
;; というわけで，どこまで近似するかをうまく設定する必要があります．

;; 名前呼びにするというようなことはまだ考えていません．
;;  あちこち (lambda () ...) をくっつければいいのではないでしょうか．

;; 平井洋一
;; # 今週金曜まで出稼ぎ中なので，続きは土日です．

;; > > ----------------------------------------
;; > > スキーマ
;; > > ----------------------------------------
;; > > table mail {
;; > >     id int primary key,
;; > >     from varchar[50],
;; > >     date datetime,
;; > >     mailbox varchar[50]
;; > > }
;; > > id と datetime は Ord のインスタンスで、
;; > > from と mailbox は Eq のインスタンスであれば OK。
;; > > 上記は演算に必要な要素のみ書いてあるので、
;; > > 必要に応じて subject とか、text とか attachment など
;; > > 加えてください。
;; from はSQL的に予約語なので，from_addrにしておきます．
;; (from_lineのほうがしっくりきますか，もしかして)


(define ex1
;; > > ----------------------------------------
;; > > 演算1
;; > > ----------------------------------------
;; > > 差出人が john@example.com のメールを全件取得。; modified by yh
;; > > (filter)
(cons
'(filter (lambda (x) (= (cadr x) "john@example.com")) (mail))
;; cadr, とかなんとかならんか．

"select * from mail where from_addr='john@example.com'"
))


(define ex2
;; > > 
;; > > ----------------------------------------
;; > > 演算2
;; > > ----------------------------------------
;; > > 日付順にメールを全件取得。
;; > > (sort)
(cons
;; input:
'(sort (lambda (x y) (< (date x) (date y))) (mail))

;; output:
"select * from mail order by date"
))

(define ex3
;; > > 
;; > > ----------------------------------------
;; > > 演算3
;; > > ----------------------------------------
;; > > 差出人メールアドレスのドメインのみを取得。
;; > > (map, sort)
(cons
;; input:
'(map domain (map from_addr (mail)))

;; output:
"select domain(from_addr) from mail"
))

;; > > ----------------------------------------
;; > > 演算4
;; > > ----------------------------------------
;; > > メールボックス毎にメール数を取得。
;; > > (fold)
;; answer changed from the orignal mail.
;; input:

;; TODO add answer.

;; output:
;; select count(*) from mail group by mailbox

(define ex5
;; > > ----------------------------------------
;; > > 演算5
;; > > ----------------------------------------
;; > > 最新 1 週間以内のメールを、
;; > > 日付が新しいものから順に最大20件取得。
;; > > (filter, map, sort)
(cons 
;; input:
'(take (sort (lambda (x y) (> (date x) (date y))) (mail)) 20)
;; [評価順序はとりあえず無視 ← やはりHaskellがいいのではないか]

;; output:
"select * from mail where date >= currentdate() - 14 order by date desc limit 20"
))

;; > > ----------------------------------------
;; > > 演算6
;; > > ----------------------------------------
;; > > 差出人毎に、メールアドレスとそのメール数を
;; > > メール数が多い順に最大20件取得。
;; > > (filter, map, sort, fold)
;; input:
;; ?

;; output:
;; select from_addr, count(*) as A1 from mail group by from_addr order by A1 desc limit 20


;; > > ----------------------------------------
;; > > 演算7
;; > > ----------------------------------------
;; > > メールボックス box1 に存在し、
;; > > メールボックス box2 に存在しないメールを、
;; > > 最新のものから順に全件取得。
;; > > (sort, join)
;; これは，テーブル構成を変えないとあまりおもしろいことにならないような気がしますね．
;; mailboxを独立したテーブルにするとか．

;; > > --------------------------------------------------------------------------------
;; > > 
;; > > 
;; > > 
;; > > 以下は、星野の考察であり、
;; > > まだあまりまとまっていない部分もありますので，参考程度に扱ってください。
;; > > 
;; > > --------------------------------------------------------------------------------
;; > > とりあえずのゴール。
;; > > --------------------------------------------------------------------------------
;; > > ・リスト内包表記 --> 条件を満たすレコード取得および型変換(projection) SQL への変換。
;; > > ・集合演算関数の合成 --> SQL を合成して 1 つの SQL に変換。
;; > > 
;; > > write 系についてはまだあまり考えていない。
;; > > 
;; > > --------------------------------------------------------------------------------
;; > > RDBMS のデータ型。
;; > > --------------------------------------------------------------------------------
;; > > ・プリミティブ型: int, char, varchar, datetime, etc.
;; > > ・レコード型: ユーザ定義データ型 (要素はプリミティブ型のみ指定可)。
;; > > 
;; > > 通常、レコード型は key を持つ。(1つ以上の要素から成る identifier)。
;; > > 要素には名前がついている(accessor)。
;; > > データベース <-> プログラムの型変換機構は適当に用意すべし。
;; > > レコード型は連想配列として実装しても良い。
;; > > 
;; > > 
;; > > --------------------------------------------------------------------------------
;; > > 集合演算関数 on Lisp layer
;; > > --------------------------------------------------------------------------------
;; > > 要素を扱う演算。
;; > > 以下のインターフェース定義は Haskell 風。
;; > > a, b, c はレコード型、d, e はプリミティブ型である。
;; > > 
;; > > filter :: [a -> Bool] -> [a] -> [a]
;; > >   (a -> Bool): 条件
;; > >   Selection from a table (not tables).
;; > > 
;; > > map :: (a -> b) -> [a] -> [b]
;; > >   write 系がなければ、データベース側でやらなくてもあまり問題はない。
;; > > 
;; > > sort :: Ord d => (a -> d) -> [a] -> [a]
;; > >   (a -> d) は、通常、レコード型 --> 数値 の変換である。
;; > >   ただの要素への accessor を指定すれば、要素順に sort してくれる。
;; > >   昇順、降順の指定も含めて、(a -> d) に含めるべき。
;; > > 
;; > > fold :: Eq e => (a -> e) -> (a -> b) -> [a] -> [b]
;; > >   (a -> e) は group by でグループを判定する演算に相当。
;; > >   (a -> b) は畳み込みの演算に相当。fold 系オペレータが入っている必要アリ。
;; > > 
;; > > join :: [a -> b -> Bool] -> (a -> b -> c) -> [a] -> [b] -> [c]
;; > >   (a -> b -> Bool): a と b にまたがる条件。
;; > >   (a -> b -> c): a と b から c データを合成。projection。
;; > >                  将来的には map と組み合わせる機能があれば必要なくなる。
;; > >   3 つ以上の table を join するインターフェースの方がいいかも。
;; > >   join じゃなくて product でも OK。
;; > >   ただし、その場合は、product と filter の合成を (join が実行されるように)
;; > >   1 つの select 文に変換しないとマズイ。
;; > > 
;; > > 集合そのものを扱う演算。
;; > > union, minus, intersect :: [a] -> [a] -> [a]
;; > > 
;; > > 
;; > > --------------------------------------------------------------------------------
;; > > MySQLマニュアル
;; > > --------------------------------------------------------------------------------
;; > > http://dev.mysql.com/doc/refman/5.5/en/index.html
;; > > 特に、Functions and Operators 節や SQL Statement syntax 節を参照されたし。
;; > > 
;; > > ----------------------------------------
;; > > よく使う集合演算オペレータ
;; > > ----------------------------------------
;; > > sort 系 (order by): asc, dsc,
;; > > fold 系 (group by): count, sum, max, min, avg, ...
;; > > 集合系: in, except(minus), union, any
;; > >   except は MySQL では未サポート。not exists などで代用。
;; > >   サブクエリを用いることで、SQL を合成できそう。
;; > > その他: limit
;; > > 
;; > > ----------------------------------------
;; > > よく使う二項演算子
;; > > ----------------------------------------
;; > > Num -> Num -> Num:  +, -, *, /, MOD, %, DIV, EXP, POW, LOG
;; > > Num -> Num -> Bool: =, !=, <, <=, >, >=, <=>
;; > > Bool -> Bool -> Bool: and, or, not
;; > > String -> Bool: like, regexp  (これは二項演算子ではない気がする)
;; > > 
;; > > これらがサポートされていれば、ほとんどの用途で十分だと思われる。
;; > > リテラルをそのまま渡すインターフェースにすれば、任意のオペレータをそのまま使えるが。。。
;; > > 
;; > > --------------------------------------------------------------------------------


